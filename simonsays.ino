//  .oooooo..o      ooooo      ooo        ooooo        .oooooo.        ooooo      ooo 
// d8P'    `Y8      `888'      `88.       .888'       d8P'  `Y8b       `888b.     `8' 
// Y88bo.            888        888b     d'888       888      888       8 `88b.    8  
//  `"Y8888o.        888        8 Y88. .P  888       888      888       8   `88b.  8  
//      `"Y88b       888        8  `888'   888       888      888       8     `88b.8  
// oo     .d8P       888        8    Y     888       `88b    d88'       8       `888  
// 8""88888P'       o888o      o8o        o888o       `Y8bood8P'       o8o        `8  
// 
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£à‚£ø‚£ø‚£ø‚£ø‚£ø‚£á‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚£§‚£§‚°Ä‚†Ä‚£†‚£º‚£ø‚£ø‚£ø‚†ø‚†ø‚¢Ø‚°ø‚†ø‚¢§‚°Ä‚†Ä‚£Ä‚£Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚£ø‚£ø‚£ø‚£ø‚£ø‚£æ‚£ø‚£ø‚£ø‚£ø‚°ù‚†Ä‚†Ä‚†Ä‚†à‚†∏‚†ó‚†Ω‚£º‚£ø‚£ø‚£ø‚£ø‚¢Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£¥‚£∑‚£ß‚£§‚°Ä‚¢∞‚£∑‚£ª‚£ø‚£ø‚£ø‚£ø‚°è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†â‚¢π‚£ø ___  ‚°ù‚£¥‚£Ø‚£ç ___‚†Ä‚†à‚°å‚°ü‚†õ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∏‚£ø‚£ø‚£ø‚£ø‚£Ω‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†£‚£∫‚£ó‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£ü‚£ù‚¢ª‚°ø‚†ü‚£ª‚°ü‚†ã‚†â‚¢ã‚°ü‚£∑‚†é‚£Ñ‚¢Å‚†ä‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£ø‚£ø‚°á‚†Ä‚°Ä‚£ø‚°ß‚†Ä‚°¥‚°æ‚†∞‚†Å‚¢ô‚£¶‚£≠‚£º‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ª‚£ø‚£ø‚£æ‚£Ñ‚£ø‚£ø‚£æ‚£Ü‚£§‚£ñ‚£†‚£æ‚°ó‚£æ‚°ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ü‚¢∞‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°†‚†§‚£†‚£∂‚£ù‚£ø‚£ø‚£ø‚£ø‚°õ‚†ë‚¢©‚£ø‚°ø‚†ì‚†õ‚†â‚£Å‚¢é‚£Æ‚£∞‚£ø‚£è‚¢∂‚£§‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£∑‚£ø‚£∂‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ì‚£ø‚£ø‚£ø‚†Ä‚†Ä‚£Ä‚£∑‚¢ø‚£ø‚£ø‚£ø‚†©‚¢ô‚£Ø‚£ó‚£é‚£≠‚£≤‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£ø‚£ø‚£ø‚£Ø‚£Ω‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°∑‚°∂‚¢ª‚¢ø‚£ø‚£ø‚£ø‚£ø‚£©‚†Ä‚†Ñ‚†∞‚†ç‚¢¢‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚¢Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£á‚£†‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£≠‚†Å‚†à‚†ô‚¢ª‚£ã‚£π‚†ê‚†Ä‚£ø‚£ø‚£ø‚£ø‚£∑‚£ñ‚†Å‚°Ä‚†Ä‚†ì‚¢£‚†Ä‚†Ä‚†Ä
// ‚†Ä‚£†‚†æ‚†ô‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†ø‚†Å‚†Ä‚†Ä‚†Ä‚†π‚¢Å‚†ë‚†Ä‚°ò‚°ø‚£ø‚£ø‚£ø‚£Ø‚¢Ç‚£Ñ‚°Ä‚†ò‚£≥‚°Ü‚†Ä‚†Ä
// ‚£º‚£∑‚£è‚£†‚£å‚£®‚£ø‚£ø‚£ø‚£ø‚°ü‚†ã‚¢†‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£Æ‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚¢£‚£à‚†Å‚¢É‚°π‚£ø‚£ø‚£ø‚£ø‚£ñ‚†é‚†Å‚†Ä‚†Å‚°∏‚°Ä‚†Ä
// ‚£ø‚£ø‚°ø‚£ø‚£Ø‚°ø‚¢µ‚£ø‚£ø‚£ø‚°∂‚¢Ü‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†õ‚†õ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ó‚†ë‚†à‚†Å‚°π‚£ø‚†ª‚£ø‚£ø‚£∑‚£µ‚£¶‚£§‚†ä‚†Å‚†Ä
// ‚†π‚£ø‚£Ø‚£Ω‚£ø‚£æ‚£∑‚°ü‚†ô‚†ª‚¢Ø‚†ã‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£æ‚£§‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚†ô‚†®‚¢î‚†Ö‚£ø‚°Ä‚†à‚£ª‚£ø‚£ø‚°á‚†ë‚†´‚†ë‚°Ñ
// ‚†Ä‚†à‚†ª‚¢ø‚£ø‚£ø‚°ü‚†ª‚¢¶‚£§‚†É‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ã‚†ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£û‚££‚¢¥‚¢∫‚£ø‚°á‚¢†‚£ø‚£ø‚£ø‚†Ç‚†Ç‚†Ä‚†É‚¢°
// ‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚°ø‚¢ø‚£§‚£§‚°ú‚†Ä‚†ò‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚°ã‚°∑‚°Ç‚¢Ä‚†Ä‚†Ä‚†Ä‚°Ä‚†Ä‚†Ä‚£ó‚£ø‚£ì‚£æ‚£ø‚†á‚¢∏‚£ø‚£ø‚£ø‚£ß‚††‚†Ä‚¢≤‚£∏
// ‚†Ä‚†Ä‚†Ä‚†à‚†ª‚¢ø‚£¶‚£ñ‚°∫‚†Å‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£µ‚†ê‚°à‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∑‚£ù‚£Ñ‚£ø‚£ø‚†Ä‚¢∏‚£ø‚£ø‚£∑‚†ä‚†Ä‚†Ä‚£¢‚°á
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°ü‚°ª‚¢π‚£ø‚†á‚†Ä‚†ò‚£ø‚£ø‚£∑‚£∑‚£•‚£Ñ‚°ø‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ω‚£ø‚£ø‚£ø‚£ø‚£´‚°ü‚†ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚¢ó‚£Ω‚£æ‚£Ø‚°Ñ‚†Ä‚¢Ä‚£æ‚†ø‚°ü‚¢ø‚¢ü‚£ã‚†Å‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£ß‚£§‚£§‚£Ñ‚£†‚°§‚£¥‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£ø‚£ü‚¢Å‚¢∏‚†Å‚†§‚££‚°ü‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£§‚¢¶‚†ú‚£∑‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ö‚†à‚†Ä‚†®‚¢™‚¢Å‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£µ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚¢ø‚£∑‚°ü‚°†‚°∑‚†Å‚¢Ç‚†ß‚¢π‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∏‚£ø‚£ø‚£ø‚°ª‚¢ø‚£ø‚£ø‚£ø‚£ø‚†ø‚†ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ß‚£ø‚£ø‚£á‚£Ω‚°á‚£†‚£æ‚¢π‚°é‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚†•‚†ì‚†ä‚†ù‚£ª‚£ø‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚°ø‚°ø‚°ø‚†ü‚¢ë‚£æ‚†Ä‚†à‚†õ‚†ì‚†ö‚†õ‚†ö‚†Å‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°ä‚¢Ä‚†Ä‚†Ä‚†ê‚£ø‚†Ä‚†Ä‚£ø‚£ø‚£ø‚°ø‚†â‚¢†‚¢Å‚°Ä‚†º‚°ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£ø‚£ø‚°ø‚¢í‚°ê‚£Ñ‚£¥‚°ø‚†Ä‚†Ä‚¢π‚£ø‚£ø‚£ø‚¢Ä‚†Ä‚†Ä‚¢Ä‚£≠‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚°ø‚¢æ‚†ø‚¢ø‚°æ‚†Å‚†Ä‚†Ä‚†à‚¢ø‚£ø‚£ø‚£ø‚†∑‚†ø‚°æ‚£æ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ω‚£ø‚£ø‚£ø‚£á‚£†‚£¥‚°é‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£æ‚°Ö‚£å‚£ø‚°Ö‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚¢è‚†â‚†â‚¢π‚¢∑‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°è‚†Å‚†Ä‚†™‚£±‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚°ø‚†ø‚†ß‚†Ä‚†Ä‚£∫‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚¢Ñ‚†Ä‚†Ñ‚†å‚°â‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚°É‚†Ä‚°Ä‚†Ä‚¢†‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚°Ñ‚†ó‚†Ä‚¢Ä‚£∏‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢π‚£ø‚£ø‚£∑‚¢û‚°î‚†Ä‚†∫‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ß‚°Ç‚¢Ä‚†¥‚£∂‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ø‚£ø‚£ø‚†á‚†Ä‚¢†‚£É‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚°ü‚£è‚¢Ä‚£π‚°è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚†§‚£∂‚£ø‚£ø‚£ø‚£ø‚£ó‚†í‚¢ø‚£∑‚°Ñ‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£ø‚£ø‚£∑‚†ö‚¢≥‚£æ‚£¶‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£§‚£∂‚£æ‚£•‚°æ‚£ø‚†ü‚£´‚£æ‚£ø‚£ø‚£Ñ‚£§‚£ø‚£ø‚†Ä‚†Ä‚°º‚£æ‚£ø‚£©‚£ø‚£ø‚£∑‚£π‚£ø‚°ø‚¢Æ‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£∑‚£æ‚£Ø‚£∏‚£ø‚£ø‚°ø‚¢â‚£Ä‚¢π‚£ø‚£ø‚£ß‚£æ‚£ø‚£Ø‚£Ω‚£ø‚£ø‚£ø‚†á‚†â‚£ø‚£ß‚£¶‚£±‚°µ‚£Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°∫‚¢º‚£ø‚£ø‚£ó‚°ä‚£ò‚£π‚°õ‚¢ã‚£ø‚£ø‚£ü‚†™‚¢ª‚£ø‚£ø‚£ø‚†Ç‚†ß‚£Ω‚£ø‚£ß‚†Å‚†Ä‚£ü‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚†â‚†Ä‚†â‚†â‚†õ‚†ì‚†í‚†í‚†ö‚†Å‚†à‚†õ‚†ª‚†ß‚†§‚†õ‚†õ‚†ø‚†Ø‚†ø‚†¨‚†û‚†õ‚†ª‚†≠‚†ù‚†ì‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä

// First choose a gamemode (choose a color)
// Then press the black button to start

// Gamemodes:
// Yellow - Classic
  // Press the buttons in the same sequence the lights flashed
// Blue - Musical
  // Press the buttons in the same sequence the melody played
// Red - Backwards
  // Remember the sequence and input it backwards
// Green - Silly
  // Generates random lights/noises no input
// White - Hmm

// Pin assignments
const int Y_led = 2;
const int Y_button = 3;
const int B_led = 4;
const int B_button = 5;
const int R_led = 6;
const int R_button = 7;
const int G_led = 8;
const int G_button = 9;
const int W_led = 10;
const int W_button = 11;
const int buzzer =  12;
const int Start_button = 13;
// Initialize empty arrays to hold light sequences
const int sequence_length  = 35;
int replay_sequence[sequence_length] = {};
int user_sequence[sequence_length] = {};
// Sequence index trackers
int replay_light = 0;
int user_light = 0; 
// Gamemode slection variable (99 is defualt)
int gamemode = 99;
// Difficulty: have to beat a sequence with this amount of lights to win
// Only affects classic and backwards and backwards is about half as long
const int difficulty = 10;
// Melody variables for musical mode
int melody;
int start;
// Easter egg :O
bool easter_egg_check = false;

void generate_sequence() {
	// Add new random light to end of replay sequence
	switch(random(5)){
		case 0:
			replay_sequence[replay_light] = Y_led;
			break;
		case 1:
			replay_sequence[replay_light] = B_led;
			break;
		case 2:
			replay_sequence[replay_light] = R_led;
			break;
		case 3:
			replay_sequence[replay_light] = G_led;
			break;
		case 4:
			replay_sequence[replay_light] = W_led;
			break;
		default:
			break;
	}
	// Increment to next replay light
	replay_light++;
}

void run_sequence() {
	// Play light sequence
	for(int j = 0; j < replay_light; j++){
	// Turn off previous light
		if(j > 0){
			digitalWrite(replay_sequence[j-1], LOW);
			delay(250);
		}
		// Turn on current light
		digitalWrite(replay_sequence[j], HIGH);
		// Buzzer control
		switch(replay_sequence[j]){
			case Y_led:
				// C4
				tone(buzzer, 262);
				break;
			case B_led:
				// E4
				tone(buzzer, 330);
				break;
			case R_led:
				// G4
				tone(buzzer, 392);
				break;
			case G_led:
				// B4
				tone(buzzer, 494);
				break;
			case W_led:
				// C5
				tone(buzzer, 523);
				break;
			default:
				break;
		}
		delay(250);
		// Reset LEDs and buzzer
		reset();
	}
}

void player_turn(bool basic) {
	// Wait for user input
	// Buttons are active LOW
	while(true){
		if(digitalRead(Y_button) == LOW){
			user_sequence[user_light] = Y_led;
			digitalWrite(Y_led, HIGH);
			delay(100);
			// Wait for user to let go of button (so it doesn't activate multiple times)
			while(digitalRead(Y_button) == LOW){}
			// If basic sounds (not musical mode)
			if(basic){
				// C4
				tone(buzzer, 262);
				delay(250);
			}
			break;
		}
		else if(digitalRead(B_button) == LOW){
			user_sequence[user_light] = B_led;
			digitalWrite(B_led, HIGH);
			delay(100);
			while(digitalRead(B_button) == LOW){}
			if(basic){
				// E4
				tone(buzzer, 330);
				delay(250);
			}
			break;
		}
		else if(digitalRead(R_button) == LOW){
			user_sequence[user_light] = R_led;
			digitalWrite(R_led, HIGH);
			delay(100);
			while(digitalRead(R_button) == LOW){}
			if(basic){
				// G4
				tone(buzzer, 392);
				delay(250);
			}
			break;
		}
		else if(digitalRead(G_button) == LOW){
			user_sequence[user_light] = G_led;
			digitalWrite(G_led, HIGH);
			delay(100);
			while(digitalRead(G_button) == LOW){}
			if(basic){
				// B4
				tone(buzzer, 494);
				delay(250);
			}
			break;
		}
		else if(digitalRead(W_button) == LOW){
			user_sequence[user_light] = W_led;
			digitalWrite(W_led, HIGH);
			delay(100);
			while(digitalRead(W_button) == LOW){}
			if(basic){
				// C5
				tone(buzzer, 523);
				delay(250);
			}
			break;
		}
	}
	// Increment to next user light
	user_light++;
	// Reset LEDs and buzzer
	reset();
}

bool check_sequence() {
	// Determine if user selected the correct buttons
	bool check = true;
	for(int l = 0; l < replay_light; l++){
		if(user_sequence[l] != replay_sequence[l]){
			check = false;
		}
	}
	return check;
}

bool check_backwards() {
	// Determine if user selected the correct buttons for backwards gamemode
	bool check = true;
	for(int l = replay_light; l > 0; l--){
		if(user_sequence[replay_light-l] != replay_sequence[l-1]){
			check = false;
		}
	}
	return check;
}

void game_over() {
	// Play losing melody and flash lights
	tone(buzzer, 523); // C5 E
	digitalWrite(W_led, HIGH);
	delay(250);
	digitalWrite(W_led, LOW);
	tone(buzzer, 493); // B4 E
	digitalWrite(G_led, HIGH);
	delay(250);
	digitalWrite(G_led, LOW);
	tone(buzzer, 392); // G4 E
	digitalWrite(R_led, HIGH);
	delay(250);
	digitalWrite(R_led, LOW);
	tone(buzzer, 493); // B4 E
	digitalWrite(G_led, HIGH);
	delay(250);
	digitalWrite(G_led, LOW);
	tone(buzzer, 392); // G4 E
	digitalWrite(R_led, HIGH);
	delay(250);
	digitalWrite(R_led, LOW);
	tone(buzzer, 329); // E4 E
	digitalWrite(B_led, HIGH);
	delay(250);
	digitalWrite(B_led, LOW);
	tone(buzzer, 392); // G4 E
	digitalWrite(R_led, HIGH);
	delay(250);
	digitalWrite(R_led, LOW);
	tone(buzzer, 329); // E4 E
	digitalWrite(B_led, HIGH);
	delay(250);
	digitalWrite(B_led, LOW);
	tone(buzzer, 261); // C4 E
	digitalWrite(Y_led, HIGH);
	delay(250);
	digitalWrite(Y_led, LOW);
	tone(buzzer, 329); // E4 E
	digitalWrite(B_led, HIGH);
	delay(250);
	digitalWrite(B_led, LOW);
	tone(buzzer, 261); // C4 Q
	digitalWrite(Y_led, HIGH);
	delay(500);
	digitalWrite(Y_led, LOW);
	tone(buzzer, 130); // C3 H
	digitalWrite(Y_led, HIGH);
	digitalWrite(B_led, HIGH);
	digitalWrite(R_led, HIGH);
	digitalWrite(G_led, HIGH);
	digitalWrite(W_led, HIGH);
	delay(1000);
	// Reset led and buzzer states
	reset();
	// Reset game
	setup();
}

void winner() {
	// Play winning melody and flash lights
	tone(buzzer, 261); // C4 E
	digitalWrite(Y_led, HIGH);
	delay(125);
	digitalWrite(Y_led, LOW);
	tone(buzzer, 329); // E4 E
	digitalWrite(B_led, HIGH);
	delay(125);
	digitalWrite(B_led, LOW);
	tone(buzzer, 261); // C4 E
	digitalWrite(Y_led, HIGH);
	delay(125);
	digitalWrite(Y_led, LOW);
	tone(buzzer, 329); // E4 E
	digitalWrite(B_led, HIGH);
	delay(125);
	digitalWrite(B_led, LOW);
	tone(buzzer, 392); // G4 E
	digitalWrite(R_led, HIGH);
	delay(125);
	digitalWrite(R_led, LOW);
	tone(buzzer, 329); // E4 E
	digitalWrite(B_led, HIGH);
	delay(125);
	digitalWrite(B_led, LOW);
	tone(buzzer, 392); // G4 E
	digitalWrite(R_led, HIGH);
	delay(125);
	digitalWrite(R_led, LOW);
	tone(buzzer, 493); // B4 E
	digitalWrite(G_led, HIGH);
	delay(125);
	digitalWrite(G_led, LOW);
	tone(buzzer, 392); // G4 E
	digitalWrite(R_led, HIGH);
	delay(125);
	digitalWrite(R_led, LOW);
	tone(buzzer, 493); // B4 E
	digitalWrite(G_led, HIGH);
	delay(125);
	digitalWrite(G_led, LOW);
	tone(buzzer, 523); // C5 H
	digitalWrite(W_led, HIGH);
	delay(500);
	// Reset led and buzzer states
	reset();
	// Reset game
	setup();
}

void classic(){
	// Classic Simon gamemode
	// First play the light sequence
	run_sequence();
	// Then recieve user inputs with basic sounds enabled
	for(int k = 0; k < replay_light; k++){  
		player_turn(true);
	}
	user_light = 0;
	// Then check if the user inputs were correct
	if(check_sequence()){
		if(replay_light > difficulty-1){
			winner();
		}
		else{
			generate_sequence();
		}
	}
	// Wrong sequence, game over
	else{
		game_over();
	}
}

void musical(){
	// Playblack the melody gamemode
	// led_array and shift are used to shift the lights as seen in the switch statement
	int led_array[10] = {Y_led, B_led, R_led, G_led, W_led, Y_led, B_led, R_led, G_led, W_led};
	int shift = random(4);
	// num_notes keeps track of the amount of notes played each turn
	int num_notes;
	// Check win condition variable
	bool win = false;
	// Melody declerations
	int minecraft_notes[] = {493, 440, 329, 392, 493, 440, 329, 293, 493, 440, 329, 392, 493, 440, 329, 392, 293};
	int minecraft_delays[] = {500, 250, 500, 750, 500, 250, 500, 750, 500, 250, 500, 750, 500, 250, 500, 250, 750};
	int nokia_notes[] = {659, 587, 369, 415, 554, 493, 293, 329, 493, 440, 277, 329, 440};
	int nokia_delays[] = {166, 166, 333, 333, 166, 166, 333, 333, 166, 166, 333, 333, 666, 666};
	int ode_notes[] = {330, 330, 349, 392, 392, 349, 330, 294, 262, 262, 294, 330, 330, 294, 294, 330, 330, 349, 392, 392, 349, 330, 294, 262, 262, 294, 330, 294, 262, 262};
	int ode_delays[] = {364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 572, 156, 832, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 572, 156, 832};
	// This switch statement switches to the randomly chosen melody
	switch(melody){
		case 0:
			// Minecraft
			if(start < 8){
				num_notes = 8;
				// Set lights to match the melody
				// Shift the lights so it isn't always the same
				replay_sequence[replay_light++] = led_array[0 + shift];
				replay_sequence[replay_light++] = led_array[1 + shift];
				replay_sequence[replay_light++] = led_array[2 + shift];
				replay_sequence[replay_light++] = led_array[3 + shift];
				replay_sequence[replay_light++] = led_array[0 + shift];
				replay_sequence[replay_light++] = led_array[1 + shift];
				replay_sequence[replay_light++] = led_array[2 + shift];
				replay_sequence[replay_light++] = led_array[4 + shift];
			}
			else{
				// Last set of notes
				num_notes = 9;
				// If player beats this turn they should win
				win = true;
				replay_sequence[replay_light++] = led_array[0 + shift];
				replay_sequence[replay_light++] = led_array[1 + shift];
				replay_sequence[replay_light++] = led_array[2 + shift];
				replay_sequence[replay_light++] = led_array[3 + shift];
				replay_sequence[replay_light++] = led_array[0 + shift];
				replay_sequence[replay_light++] = led_array[1 + shift];
				replay_sequence[replay_light++] = led_array[2 + shift];
				replay_sequence[replay_light++] = led_array[3 + shift];
				replay_sequence[replay_light++] = led_array[4 + shift];
			}
			// Run chosen sequence
			musical_sequence(minecraft_notes, minecraft_delays, num_notes, start);
			user_light = start;
			// Add offset based on how many notes were played last turn
			start += 8;
			break;
		case 1:
			// Nokia
			// Set lights to match the melody
			if(start < 8){
				num_notes = 4;
			        replay_sequence[replay_light++] = led_array[0 + shift];
			        replay_sequence[replay_light++] = led_array[1 + shift];
			        replay_sequence[replay_light++] = led_array[2 + shift];
			        replay_sequence[replay_light++] = led_array[3 + shift];
			}
			else{
				num_notes = 5;
			        win = true;
			        replay_sequence[replay_light++] = led_array[0 + shift];
			        replay_sequence[replay_light++] = led_array[1 + shift];
			        replay_sequence[replay_light++] = led_array[2 + shift];
			        replay_sequence[replay_light++] = led_array[3 + shift];
			        replay_sequence[replay_light++] = led_array[4 + shift];
			}
			// Run chosen sequence
			musical_sequence(nokia_notes, nokia_delays, num_notes, start);
			user_light = start;
			start += 4;
			break;
		case 2:
			// Ode to Joy
			// Set lights to match the melody
			if(start == 0 | start == 15){
				num_notes = 4;
				replay_sequence[replay_light++] = led_array[0 + shift];
				replay_sequence[replay_light++] = led_array[0 + shift];
				replay_sequence[replay_light++] = led_array[1 + shift];
				replay_sequence[replay_light++] = led_array[2 + shift];
			}
			else if(start == 4 | start == 19){
				num_notes = 4;
				replay_sequence[replay_light++] = led_array[2 + shift];
				replay_sequence[replay_light++] = led_array[1 + shift];
				replay_sequence[replay_light++] = led_array[0 + shift];
				replay_sequence[replay_light++] = led_array[3 + shift];
			}
			else if(start == 8 | start == 23){
				num_notes = 4;
				replay_sequence[replay_light++] = led_array[4 + shift];
				replay_sequence[replay_light++] = led_array[4 + shift];
				replay_sequence[replay_light++] = led_array[3 + shift];
				replay_sequence[replay_light++] = led_array[0 + shift];
			}
			else if(start == 12){
				num_notes = 3;
				replay_sequence[replay_light++] = led_array[0 + shift];
				replay_sequence[replay_light++] = led_array[3 + shift];
				replay_sequence[replay_light++] = led_array[3 + shift];
			}
			else{
				num_notes = 3;
				replay_sequence[replay_light++] = led_array[3 + shift];
				replay_sequence[replay_light++] = led_array[4 + shift];
				replay_sequence[replay_light++] = led_array[4 + shift];
				win = true;
			}
			// Run chosen sequence
			musical_sequence(ode_notes, ode_delays, num_notes, start);
			user_light = start;
			start += num_notes;
			break;
		default:
			break;
	}
	// Recieve user inputs with basic sounds disabled
	for(int k = 0; k < num_notes; k++){  
		player_turn(false);
	}
	// Then check if the user inputs were correct
	if(check_sequence()){
		if(win){
			winner();
		}
	}
		// Wrong sequence, game over
	else{
		game_over();
	}
}

void musical_sequence(int notes[], int delays[], int num_notes, int start){
	// Play the melody for the musical gamemode
	// Offset by start amount and play num_notes amount of notes
	for(int w = start; w < num_notes+start; w++){
		// Turn off previous light
		if(w > 0){
			digitalWrite(replay_sequence[w-1], LOW);
			delay(250);
		}
		// Turn on current light
		digitalWrite(replay_sequence[w], HIGH);
		// Play current note in song
		tone(buzzer, notes[w]);
		delay(delays[w]);
	}
	// Reset leds and buzzer
	reset();
}

void backwards(){
	// Start with the entire sequence and remove a light each time
	// Entire sequence was generated in setup
	// First playback the sequence
	run_sequence();
	// Then recieve user inputs with basic sounds enabled
	for(int k = 0; k < replay_light; k++){  
		player_turn(true);
	}
	user_light = 0;
	// Then check if the user inputs were correct
	if(check_backwards()){
		if(replay_light == 0){
			winner();
		}
		else{
			// Remove last light in sequence
			replay_sequence[replay_light] = '\0';
			replay_light--;
		}
	}
		// Wrong sequence, game over
	else{
		game_over();
	}
}

void silly(){
	// Just some random garbage üëç
	// Feel free to delete
	for(int silly = 0; silly < 11; silly++){
		int rando = random(6);
		int randooo = random(20);
		digitalWrite(rando*2, HIGH);
		tone(buzzer, randooo*100);
		delay(250);
		noTone(buzzer);
		digitalWrite(randooo*2, LOW);
	}
	reset();
	setup();
}

void hmm(){
	// Har Har Har
	tone(buzzer, 784); // G5 Q
	digitalWrite(W_led, HIGH);
	delay(600);
	tone(buzzer, 880); // A5 .E
	digitalWrite(G_led, HIGH);
	delay(450);
	tone(buzzer, 784); // G5 S
	digitalWrite(Y_led, HIGH);
	delay(150);
	tone(buzzer, 659); // E5 Q
	digitalWrite(R_led, HIGH);
	delay(525);
	noTone(buzzer); // consecutive delay
	delay(75);
	tone(buzzer, 659); // E5 Q
	digitalWrite(B_led, HIGH);
	delay(525);
	noTone(buzzer); // consecutive delay
	delay(75);
	tone(buzzer, 659); // E5 .E
	digitalWrite(W_led, LOW);
	delay(450);
	tone(buzzer, 587); // D5 S
	digitalWrite(G_led, LOW);
	delay(150);
	tone(buzzer, 659); // E5 .E
	digitalWrite(Y_led, LOW);
	delay(450);
	tone(buzzer, 698); // F5 S
	digitalWrite(R_led, LOW);
	delay(150);
	tone(buzzer, 659); // E5 H
	digitalWrite(B_led, LOW);
	delay(1200);
	tone(buzzer, 698); // F5 Q
	digitalWrite(G_led, HIGH);
	delay(600);
	tone(buzzer, 587); // D5 .E
	digitalWrite(B_led, HIGH);
	delay(450);
	tone(buzzer, 784); // G5 s
	digitalWrite(R_led, HIGH);
	delay(150);
	tone(buzzer, 659); // E5 H
	digitalWrite(Y_led, HIGH);
	delay(1200);
	tone(buzzer, 523); // C5 Q
	digitalWrite(W_led, HIGH);
	delay(600);
	tone(buzzer, 440); // A4 .E
	digitalWrite(Y_led, LOW);
	digitalWrite(G_led, LOW);
	digitalWrite(R_led, LOW);
	digitalWrite(B_led, LOW);
	digitalWrite(W_led, LOW);
	delay(450);
	tone(buzzer, 587); // D5 S
	digitalWrite(Y_led, HIGH);
	digitalWrite(G_led, HIGH);
	digitalWrite(R_led, HIGH);
	digitalWrite(B_led, HIGH);
	digitalWrite(W_led, HIGH);
	delay(150);
	tone(buzzer, 415); // G#4 H
	digitalWrite(W_led, LOW);
	delay(600);
	digitalWrite(G_led, LOW);
	delay(300);
	digitalWrite(Y_led, LOW);
	delay(150);
	digitalWrite(R_led, LOW);
	delay(75);
	digitalWrite(B_led, LOW);
	noTone(buzzer);
	setup();
}

void reset(){
	// Reset all leds and the buzzer
	digitalWrite(Y_led, LOW);
	digitalWrite(B_led, LOW);
	digitalWrite(R_led, LOW);
	digitalWrite(G_led, LOW);
	digitalWrite(W_led, LOW);
	noTone(buzzer);
	delay(250);
}

void setup() {
	// Randomize seed (A0 should be floating and therefore random)
	randomSeed(analogRead(A0));
	// Setting pin modes
	pinMode(Y_led, OUTPUT);
	pinMode(B_led, OUTPUT);
	pinMode(R_led, OUTPUT);
	pinMode(G_led, OUTPUT);
	pinMode(W_led, OUTPUT);
	pinMode(buzzer, OUTPUT);
	pinMode(Y_button, INPUT_PULLUP);
	pinMode(B_button, INPUT_PULLUP);
	pinMode(R_button, INPUT_PULLUP);
	pinMode(G_button, INPUT_PULLUP);
	pinMode(W_button, INPUT_PULLUP);
	pinMode(Start_button, INPUT_PULLUP);
	//hmm();
	// Empty arrays with null character
	for(int n = 0; n <= sequence_length; n++){
		replay_sequence[n] = '\0';
		user_sequence[n] = '\0';
	}
	// Reset light counters
	replay_light = 0;
	user_light = 0;

	// Reset gamemode to default
	gamemode = 99;
	
	// Wait for user to choose a game mode
	while(true){
		if(digitalRead(Y_button) == LOW){
			// Classic
			gamemode = 0;
			while(digitalRead(Y_button) == LOW){
				// Easter egg check, if Y is held and then R is pressed, the easter egg is enabled
				if(digitalRead(R_button) == LOW){
				  easter_egg_check = true;
				}
			}
			reset();
			digitalWrite(Y_led, HIGH);
			// C4
			tone(buzzer, 262);
			delay(250);
			noTone(buzzer);
		}
		else if(digitalRead(B_button) == LOW){
			// Musical
			gamemode = 1;
			while(digitalRead(B_button) == LOW){}
			reset();
			digitalWrite(B_led, HIGH);
			// E4
			tone(buzzer, 330);
			delay(250);
			noTone(buzzer);
		}
		else if(digitalRead(R_button) == LOW){
			// Backwards
			gamemode = 2;
			while(digitalRead(R_button) == LOW){}
			reset();
			digitalWrite(R_led, HIGH);
			// G4
			tone(buzzer, 392);
			delay(250);
			noTone(buzzer);
		}
		else if(digitalRead(G_button) == LOW){
			// Silly
			gamemode = 3;
			while(digitalRead(G_button) == LOW){}
			reset();
			digitalWrite(G_led, HIGH);
			// B4
			tone(buzzer, 494);
			delay(250);
			noTone(buzzer);
		}
		else if(digitalRead(W_button) == LOW){
			// hmm
			gamemode = 4;
			while(digitalRead(W_button) == LOW){}
			reset();
			digitalWrite(W_led, HIGH);
			// C5
			tone(buzzer, 523);
			delay(250);
			noTone(buzzer);
		}
		else if(digitalRead(Start_button) == LOW){
			delay(100);
			// Wait for user to let go of button (so it doesn't activate multiple times)
			while(digitalRead(Start_button) == LOW){}
			switch(gamemode){
				case 0:
					// classic
					// Generate first of sequence
					generate_sequence();
					break;
				case 1:
					// musical
					// Choose random melody
					melody = random(3);
					start = 0;
					break;
				case 2:
					// backwards
					// Generate entire sequence
					for(int i = 0; i < round(difficulty-5); i++){
						generate_sequence();
					}
					break;
				case 99:
					// No selection yet, do nothing
					continue;
				default:
					break;
			}
			// After selection is confirmed, play start sequence/melody
			start_song();
			// Reset led and buzzer states
			reset();
			break;
		}
	}
}
void start_song() {
	// This is the start song
	digitalWrite(Y_led, HIGH);
	digitalWrite(B_led, HIGH);
	digitalWrite(R_led, HIGH);
	digitalWrite(G_led, HIGH);
	digitalWrite(W_led, HIGH);
	// C4
	tone(buzzer, 262);
	delay(200);
	// A4
	tone(buzzer, 440);
	delay(400);
	// G4
	tone(buzzer, 392);
	delay(100);
	// E4
	tone(buzzer, 330);
	delay(100);
	// B4
	tone(buzzer, 494);
	delay(200);
	// C5
	tone(buzzer, 524);
	delay(150);
}

void easter_egg() {
  // ü•ö
}

void loop() {
	delay(250);
	// Main game loop, calls all other functions and loops
  // Easter egg!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
  if(easter_egg_check){
    easter_egg();
  }
	// Gamemode switch
	switch(gamemode){
		case 0:
			classic();
			break;
		case 1:
			musical();
			break;
		case 2:
			backwards();
			break;
		case 3:
			silly();
			break;
		case 4:
			hmm();
			break;
		default:
			break;
	}
}
