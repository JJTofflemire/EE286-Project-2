//  .oooooo..o      ooooo      ooo        ooooo        .oooooo.        ooooo      ooo 
// d8P'    `Y8      `888'      `88.       .888'       d8P'  `Y8b       `888b.     `8' 
// Y88bo.            888        888b     d'888       888      888       8 `88b.    8  
//  `"Y8888o.        888        8 Y88. .P  888       888      888       8   `88b.  8  
//      `"Y88b       888        8  `888'   888       888      888       8     `88b.8  
// oo     .d8P       888        8    Y     888       `88b    d88'       8       `888  
// 8""88888P'       o888o      o8o        o888o       `Y8bood8P'       o8o        `8  
// 
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣈⣿⣿⣿⣿⣿⣇⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣤⣤⡀⠀⣠⣼⣿⣿⣿⠿⠿⢯⡿⠿⢤⡀⠀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⡝⠀⠀⠀⠈⠸⠗⠽⣼⣿⣿⣿⣿⢆⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣴⣷⣧⣤⡀⢰⣷⣻⣿⣿⣿⣿⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⢹⣿ ___  ⡝⣴⣯⣍ ___⠀⠈⡌⡟⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣽⣿⣿⣿⣿⣿⣿⣿⠣⣺⣗⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣟⣝⢻⡿⠟⣻⡟⠋⠉⢋⡟⣷⠎⣄⢁⠊⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⡇⠀⡀⣿⡧⠀⡴⡾⠰⠁⢙⣦⣭⣼⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣿⣿⣾⣄⣿⣿⣾⣆⣤⣖⣠⣾⡗⣾⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⢰⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⢀⡠⠤⣠⣶⣝⣿⣿⣿⣿⡛⠑⢩⣿⡿⠓⠛⠉⣁⢎⣮⣰⣿⣏⢶⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⣠⣾⣷⣿⣶⣿⣿⣿⣿⣿⣿⣿⣿⡓⣿⣿⣿⠀⠀⣀⣷⢿⣿⣿⣿⠩⢙⣯⣗⣎⣭⣲⣄⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⣠⣾⣿⣿⣿⣯⣽⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡷⡶⢻⢿⣿⣿⣿⣿⣩⠀⠄⠰⠍⢢⠀⠀⠀⠀
// ⠀⠀⢀⣼⣿⣿⣿⣿⣿⣿⣇⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣭⠁⠈⠙⢻⣋⣹⠐⠀⣿⣿⣿⣿⣷⣖⠁⡀⠀⠓⢣⠀⠀⠀
// ⠀⣠⠾⠙⠻⣿⣿⣿⣿⣿⣿⣿⡿⢻⣿⣿⣿⣿⣿⣿⡿⠿⠁⠀⠀⠀⠹⢁⠑⠀⡘⡿⣿⣿⣿⣯⢂⣄⡀⠘⣳⡆⠀⠀
// ⣼⣷⣏⣠⣌⣨⣿⣿⣿⣿⡟⠋⢠⣿⣿⣿⣿⣿⣿⣿⣷⣮⠁⠀⠀⠀⠀⢣⣈⠁⢃⡹⣿⣿⣿⣿⣖⠎⠁⠀⠁⡸⡀⠀
// ⣿⣿⡿⣿⣯⡿⢵⣿⣿⣿⡶⢆⣾⣿⣿⣿⣿⣿⣿⠛⠛⠋⠀⠀⠀⠀⠀⠀⣗⠑⠈⠁⡹⣿⠻⣿⣿⣷⣵⣦⣤⠊⠁⠀
// ⠹⣿⣯⣽⣿⣾⣷⡟⠙⠻⢯⠋⣿⣿⣿⣿⣿⣿⣾⣤⡀⠀⠀⠀⠀⠀⠀⠀⢸⠙⠨⢔⠅⣿⡀⠈⣻⣿⣿⡇⠑⠫⠑⡄
// ⠀⠈⠻⢿⣿⣿⡟⠻⢦⣤⠃⢸⣿⣿⣿⣿⣿⣿⣿⡋⠊⠀⠀⠀⠀⠀⠀⠀⠈⣞⣣⢴⢺⣿⡇⢠⣿⣿⣿⠂⠂⠀⠃⢡
// ⠀⠀⠀⢸⣿⡿⢿⣤⣤⡜⠀⠘⣿⣿⣿⣿⣿⣿⡿⡋⡷⡂⢀⠀⠀⠀⡀⠀⠀⣗⣿⣓⣾⣿⠇⢸⣿⣿⣿⣧⠠⠀⢲⣸
// ⠀⠀⠀⠈⠻⢿⣦⣖⡺⠁⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣵⠐⡈⠀⠀⠀⠀⠀⠀⣷⣝⣄⣿⣿⠀⢸⣿⣿⣷⠊⠀⠀⣢⡇
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⡟⡻⢹⣿⠇⠀⠘⣿⣿⣷⣷⣥⣄⡿⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣽⣿⣿⣿⣿⣫⡟⠊⠁⠀⠀⠀⠀⠀⠀⢀⢗⣽⣾⣯⡄⠀⢀⣾⠿⡟⢿⢟⣋⠁⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣷⣧⣤⣤⣄⣠⡤⣴⣿⣿⣿⣿⣿⣷⣿⣟⢁⢸⠁⠤⣣⡟⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣤⢦⠜⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡅⠈⠀⠨⢪⢁⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣵⣿⣿⣿⣿⣿⣿⣿⣿⠿⢿⣷⡟⡠⡷⠁⢂⠧⢹⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡻⢿⣿⣿⣿⣿⠿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣿⣿⣇⣽⡇⣠⣾⢹⡎⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⠥⠓⠊⠝⣻⣿⠀⠀⣿⣿⣿⣿⡿⡿⡿⠟⢑⣾⠀⠈⠛⠓⠚⠛⠚⠁⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⡊⢀⠀⠀⠐⣿⠀⠀⣿⣿⣿⡿⠉⢠⢁⡀⠼⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⡿⢒⡐⣄⣴⡿⠀⠀⢹⣿⣿⣿⢀⠀⠀⢀⣭⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⡿⢾⠿⢿⡾⠁⠀⠀⠈⢿⣿⣿⣿⠷⠿⡾⣾⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣽⣿⣿⣿⣇⣠⣴⡎⠀⠀⠀⠀⢸⣿⣿⣿⣾⡅⣌⣿⡅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⢏⠉⠉⢹⢷⠀⠀⠀⠀⢸⣿⣿⣿⡏⠁⠀⠪⣱⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⡿⠿⠧⠀⠀⣺⠀⠀⠀⠀⢸⣿⣿⣿⢄⠀⠄⠌⡉⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⡃⠀⡀⠀⢠⣿⠀⠀⠀⠀⢸⣿⣿⣿⡄⠗⠀⢀⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿⣷⢞⡔⠀⠺⡇⠀⠀⠀⠀⢸⣿⣿⣿⣧⡂⢀⠴⣶⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⠇⠀⢠⣃⠇⠀⠀⠀⠀⠀⣿⣿⣿⡟⣏⢀⣹⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠤⣶⣿⣿⣿⣿⣗⠒⢿⣷⡄⠀⠀⠀⣠⣾⣿⣿⣷⠚⢳⣾⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⣠⣤⣶⣾⣥⡾⣿⠟⣫⣾⣿⣿⣄⣤⣿⣿⠀⠀⡼⣾⣿⣩⣿⣿⣷⣹⣿⡿⢮⣇⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣷⣾⣯⣸⣿⣿⡿⢉⣀⢹⣿⣿⣧⣾⣿⣯⣽⣿⣿⣿⠇⠉⣿⣧⣦⣱⡵⣆⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠸⢿⣿⣿⣿⣿⣿⣿⡺⢼⣿⣿⣗⡊⣘⣹⡛⢋⣿⣿⣟⠪⢻⣿⣿⣿⠂⠧⣽⣿⣧⠁⠀⣟⡄⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠀⠉⠉⠛⠓⠒⠒⠚⠁⠈⠛⠻⠧⠤⠛⠛⠿⠯⠿⠬⠞⠛⠻⠭⠝⠓⠂⠀⠀⠀⠀⠀

// First choose a gamemode (choose a color)
// Then press the black button to start

// Gamemodes:
// Yellow - Classic
  // Press the buttons in the same sequence the lights flashed
// Blue - Musical
  // Press the buttons in the same sequence the melody played
// Red - Backwards
  // Remember the sequence and input it backwards
// Green - Silly
  // Generates random lights/noises no input
// White - Hmm

// Pin assignments
const int Y_led = 2;
const int Y_button = 3;
const int B_led = 4;
const int B_button = 5;
const int R_led = 6;
const int R_button = 7;
const int G_led = 8;
const int G_button = 9;
const int W_led = 10;
const int W_button = 11;
const int buzzer =  12;
const int Start_button = 13;
// Initialize empty arrays to hold light sequences
const int sequence_length  = 35;
int replay_sequence[sequence_length] = {};
int user_sequence[sequence_length] = {};
// Sequence index trackers
int replay_light = 0;
int user_light = 0; 
// Gamemode slection variable (99 is defualt)
int gamemode = 99;
// Difficulty: have to beat a sequence with this amount of lights to win
// Only affects classic and backwards and backwards is about half as long
const int difficulty = 10;
// Melody variables for musical mode
int melody;
int start;
// Easter egg :O
bool easter_egg_check = false;

void generate_sequence() {
	// Add new random light to end of replay sequence
	switch(random(5)){
		case 0:
			replay_sequence[replay_light] = Y_led;
			break;
		case 1:
			replay_sequence[replay_light] = B_led;
			break;
		case 2:
			replay_sequence[replay_light] = R_led;
			break;
		case 3:
			replay_sequence[replay_light] = G_led;
			break;
		case 4:
			replay_sequence[replay_light] = W_led;
			break;
		default:
			break;
	}
	// Increment to next replay light
	replay_light++;
}

void run_sequence() {
	// Play light sequence
	for(int j = 0; j < replay_light; j++){
	// Turn off previous light
		if(j > 0){
			digitalWrite(replay_sequence[j-1], LOW);
			delay(250);
		}
		// Turn on current light
		digitalWrite(replay_sequence[j], HIGH);
		// Buzzer control
		switch(replay_sequence[j]){
			case Y_led:
				// C4
				tone(buzzer, 262);
				break;
			case B_led:
				// E4
				tone(buzzer, 330);
				break;
			case R_led:
				// G4
				tone(buzzer, 392);
				break;
			case G_led:
				// B4
				tone(buzzer, 494);
				break;
			case W_led:
				// C5
				tone(buzzer, 523);
				break;
			default:
				break;
		}
		delay(250);
		// Reset LEDs and buzzer
		reset();
	}
}

void player_turn(bool basic) {
	// Wait for user input
	// Buttons are active LOW
	while(true){
		if(digitalRead(Y_button) == LOW){
			user_sequence[user_light] = Y_led;
			digitalWrite(Y_led, HIGH);
			delay(100);
			// Wait for user to let go of button (so it doesn't activate multiple times)
			while(digitalRead(Y_button) == LOW){}
			// If basic sounds (not musical mode)
			if(basic){
				// C4
				tone(buzzer, 262);
				delay(250);
			}
			break;
		}
		else if(digitalRead(B_button) == LOW){
			user_sequence[user_light] = B_led;
			digitalWrite(B_led, HIGH);
			delay(100);
			while(digitalRead(B_button) == LOW){}
			if(basic){
				// E4
				tone(buzzer, 330);
				delay(250);
			}
			break;
		}
		else if(digitalRead(R_button) == LOW){
			user_sequence[user_light] = R_led;
			digitalWrite(R_led, HIGH);
			delay(100);
			while(digitalRead(R_button) == LOW){}
			if(basic){
				// G4
				tone(buzzer, 392);
				delay(250);
			}
			break;
		}
		else if(digitalRead(G_button) == LOW){
			user_sequence[user_light] = G_led;
			digitalWrite(G_led, HIGH);
			delay(100);
			while(digitalRead(G_button) == LOW){}
			if(basic){
				// B4
				tone(buzzer, 494);
				delay(250);
			}
			break;
		}
		else if(digitalRead(W_button) == LOW){
			user_sequence[user_light] = W_led;
			digitalWrite(W_led, HIGH);
			delay(100);
			while(digitalRead(W_button) == LOW){}
			if(basic){
				// C5
				tone(buzzer, 523);
				delay(250);
			}
			break;
		}
	}
	// Increment to next user light
	user_light++;
	// Reset LEDs and buzzer
	reset();
}

bool check_sequence() {
	// Determine if user selected the correct buttons
	bool check = true;
	for(int l = 0; l < replay_light; l++){
		if(user_sequence[l] != replay_sequence[l]){
			check = false;
		}
	}
	return check;
}

bool check_backwards() {
	// Determine if user selected the correct buttons for backwards gamemode
	bool check = true;
	for(int l = replay_light; l > 0; l--){
		if(user_sequence[replay_light-l] != replay_sequence[l-1]){
			check = false;
		}
	}
	return check;
}

void game_over() {
	// Play losing melody and flash lights
	tone(buzzer, 523); // C5 E
	digitalWrite(W_led, HIGH);
	delay(250);
	digitalWrite(W_led, LOW);
	tone(buzzer, 493); // B4 E
	digitalWrite(G_led, HIGH);
	delay(250);
	digitalWrite(G_led, LOW);
	tone(buzzer, 392); // G4 E
	digitalWrite(R_led, HIGH);
	delay(250);
	digitalWrite(R_led, LOW);
	tone(buzzer, 493); // B4 E
	digitalWrite(G_led, HIGH);
	delay(250);
	digitalWrite(G_led, LOW);
	tone(buzzer, 392); // G4 E
	digitalWrite(R_led, HIGH);
	delay(250);
	digitalWrite(R_led, LOW);
	tone(buzzer, 329); // E4 E
	digitalWrite(B_led, HIGH);
	delay(250);
	digitalWrite(B_led, LOW);
	tone(buzzer, 392); // G4 E
	digitalWrite(R_led, HIGH);
	delay(250);
	digitalWrite(R_led, LOW);
	tone(buzzer, 329); // E4 E
	digitalWrite(B_led, HIGH);
	delay(250);
	digitalWrite(B_led, LOW);
	tone(buzzer, 261); // C4 E
	digitalWrite(Y_led, HIGH);
	delay(250);
	digitalWrite(Y_led, LOW);
	tone(buzzer, 329); // E4 E
	digitalWrite(B_led, HIGH);
	delay(250);
	digitalWrite(B_led, LOW);
	tone(buzzer, 261); // C4 Q
	digitalWrite(Y_led, HIGH);
	delay(500);
	digitalWrite(Y_led, LOW);
	tone(buzzer, 130); // C3 H
	digitalWrite(Y_led, HIGH);
	digitalWrite(B_led, HIGH);
	digitalWrite(R_led, HIGH);
	digitalWrite(G_led, HIGH);
	digitalWrite(W_led, HIGH);
	delay(1000);
	// Reset led and buzzer states
	reset();
	// Reset game
	setup();
}

void winner() {
	// Play winning melody and flash lights
	tone(buzzer, 261); // C4 E
	digitalWrite(Y_led, HIGH);
	delay(125);
	digitalWrite(Y_led, LOW);
	tone(buzzer, 329); // E4 E
	digitalWrite(B_led, HIGH);
	delay(125);
	digitalWrite(B_led, LOW);
	tone(buzzer, 261); // C4 E
	digitalWrite(Y_led, HIGH);
	delay(125);
	digitalWrite(Y_led, LOW);
	tone(buzzer, 329); // E4 E
	digitalWrite(B_led, HIGH);
	delay(125);
	digitalWrite(B_led, LOW);
	tone(buzzer, 392); // G4 E
	digitalWrite(R_led, HIGH);
	delay(125);
	digitalWrite(R_led, LOW);
	tone(buzzer, 329); // E4 E
	digitalWrite(B_led, HIGH);
	delay(125);
	digitalWrite(B_led, LOW);
	tone(buzzer, 392); // G4 E
	digitalWrite(R_led, HIGH);
	delay(125);
	digitalWrite(R_led, LOW);
	tone(buzzer, 493); // B4 E
	digitalWrite(G_led, HIGH);
	delay(125);
	digitalWrite(G_led, LOW);
	tone(buzzer, 392); // G4 E
	digitalWrite(R_led, HIGH);
	delay(125);
	digitalWrite(R_led, LOW);
	tone(buzzer, 493); // B4 E
	digitalWrite(G_led, HIGH);
	delay(125);
	digitalWrite(G_led, LOW);
	tone(buzzer, 523); // C5 H
	digitalWrite(W_led, HIGH);
	delay(500);
	// Reset led and buzzer states
	reset();
	// Reset game
	setup();
}

void classic(){
	// Classic Simon gamemode
	// First play the light sequence
	run_sequence();
	// Then recieve user inputs with basic sounds enabled
	for(int k = 0; k < replay_light; k++){  
		player_turn(true);
	}
	user_light = 0;
	// Then check if the user inputs were correct
	if(check_sequence()){
		if(replay_light > difficulty-1){
			winner();
		}
		else{
			generate_sequence();
		}
	}
	// Wrong sequence, game over
	else{
		game_over();
	}
}

void musical(){
	// Playblack the melody gamemode
	// led_array and shift are used to shift the lights as seen in the switch statement
	int led_array[10] = {Y_led, B_led, R_led, G_led, W_led, Y_led, B_led, R_led, G_led, W_led};
	int shift = random(4);
	// num_notes keeps track of the amount of notes played each turn
	int num_notes;
	// Check win condition variable
	bool win = false;
	// Melody declerations
	int minecraft_notes[] = {493, 440, 329, 392, 493, 440, 329, 293, 493, 440, 329, 392, 493, 440, 329, 392, 293};
	int minecraft_delays[] = {500, 250, 500, 750, 500, 250, 500, 750, 500, 250, 500, 750, 500, 250, 500, 250, 750};
	int nokia_notes[] = {659, 587, 369, 415, 554, 493, 293, 329, 493, 440, 277, 329, 440};
	int nokia_delays[] = {166, 166, 333, 333, 166, 166, 333, 333, 166, 166, 333, 333, 666, 666};
	int ode_notes[] = {330, 330, 349, 392, 392, 349, 330, 294, 262, 262, 294, 330, 330, 294, 294, 330, 330, 349, 392, 392, 349, 330, 294, 262, 262, 294, 330, 294, 262, 262};
	int ode_delays[] = {364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 572, 156, 832, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 364, 572, 156, 832};
	// This switch statement switches to the randomly chosen melody
	switch(melody){
		case 0:
			// Minecraft
			if(start < 8){
				num_notes = 8;
				// Set lights to match the melody
				// Shift the lights so it isn't always the same
				replay_sequence[replay_light++] = led_array[0 + shift];
				replay_sequence[replay_light++] = led_array[1 + shift];
				replay_sequence[replay_light++] = led_array[2 + shift];
				replay_sequence[replay_light++] = led_array[3 + shift];
				replay_sequence[replay_light++] = led_array[0 + shift];
				replay_sequence[replay_light++] = led_array[1 + shift];
				replay_sequence[replay_light++] = led_array[2 + shift];
				replay_sequence[replay_light++] = led_array[4 + shift];
			}
			else{
				// Last set of notes
				num_notes = 9;
				// If player beats this turn they should win
				win = true;
				replay_sequence[replay_light++] = led_array[0 + shift];
				replay_sequence[replay_light++] = led_array[1 + shift];
				replay_sequence[replay_light++] = led_array[2 + shift];
				replay_sequence[replay_light++] = led_array[3 + shift];
				replay_sequence[replay_light++] = led_array[0 + shift];
				replay_sequence[replay_light++] = led_array[1 + shift];
				replay_sequence[replay_light++] = led_array[2 + shift];
				replay_sequence[replay_light++] = led_array[3 + shift];
				replay_sequence[replay_light++] = led_array[4 + shift];
			}
			// Run chosen sequence
			musical_sequence(minecraft_notes, minecraft_delays, num_notes, start);
			user_light = start;
			// Add offset based on how many notes were played last turn
			start += 8;
			break;
		case 1:
			// Nokia
			// Set lights to match the melody
			if(start < 8){
				num_notes = 4;
			        replay_sequence[replay_light++] = led_array[0 + shift];
			        replay_sequence[replay_light++] = led_array[1 + shift];
			        replay_sequence[replay_light++] = led_array[2 + shift];
			        replay_sequence[replay_light++] = led_array[3 + shift];
			}
			else{
				num_notes = 5;
			        win = true;
			        replay_sequence[replay_light++] = led_array[0 + shift];
			        replay_sequence[replay_light++] = led_array[1 + shift];
			        replay_sequence[replay_light++] = led_array[2 + shift];
			        replay_sequence[replay_light++] = led_array[3 + shift];
			        replay_sequence[replay_light++] = led_array[4 + shift];
			}
			// Run chosen sequence
			musical_sequence(nokia_notes, nokia_delays, num_notes, start);
			user_light = start;
			start += 4;
			break;
		case 2:
			// Ode to Joy
			// Set lights to match the melody
			if(start == 0 | start == 15){
				num_notes = 4;
				replay_sequence[replay_light++] = led_array[0 + shift];
				replay_sequence[replay_light++] = led_array[0 + shift];
				replay_sequence[replay_light++] = led_array[1 + shift];
				replay_sequence[replay_light++] = led_array[2 + shift];
			}
			else if(start == 4 | start == 19){
				num_notes = 4;
				replay_sequence[replay_light++] = led_array[2 + shift];
				replay_sequence[replay_light++] = led_array[1 + shift];
				replay_sequence[replay_light++] = led_array[0 + shift];
				replay_sequence[replay_light++] = led_array[3 + shift];
			}
			else if(start == 8 | start == 23){
				num_notes = 4;
				replay_sequence[replay_light++] = led_array[4 + shift];
				replay_sequence[replay_light++] = led_array[4 + shift];
				replay_sequence[replay_light++] = led_array[3 + shift];
				replay_sequence[replay_light++] = led_array[0 + shift];
			}
			else if(start == 12){
				num_notes = 3;
				replay_sequence[replay_light++] = led_array[0 + shift];
				replay_sequence[replay_light++] = led_array[3 + shift];
				replay_sequence[replay_light++] = led_array[3 + shift];
			}
			else{
				num_notes = 3;
				replay_sequence[replay_light++] = led_array[3 + shift];
				replay_sequence[replay_light++] = led_array[4 + shift];
				replay_sequence[replay_light++] = led_array[4 + shift];
				win = true;
			}
			// Run chosen sequence
			musical_sequence(ode_notes, ode_delays, num_notes, start);
			user_light = start;
			start += num_notes;
			break;
		default:
			break;
	}
	// Recieve user inputs with basic sounds disabled
	for(int k = 0; k < num_notes; k++){  
		player_turn(false);
	}
	// Then check if the user inputs were correct
	if(check_sequence()){
		if(win){
			winner();
		}
	}
		// Wrong sequence, game over
	else{
		game_over();
	}
}

void musical_sequence(int notes[], int delays[], int num_notes, int start){
	// Play the melody for the musical gamemode
	// Offset by start amount and play num_notes amount of notes
	for(int w = start; w < num_notes+start; w++){
		// Turn off previous light
		if(w > 0){
			digitalWrite(replay_sequence[w-1], LOW);
			delay(250);
		}
		// Turn on current light
		digitalWrite(replay_sequence[w], HIGH);
		// Play current note in song
		tone(buzzer, notes[w]);
		delay(delays[w]);
	}
	// Reset leds and buzzer
	reset();
}

void backwards(){
	// Start with the entire sequence and remove a light each time
	// Entire sequence was generated in setup
	// First playback the sequence
	run_sequence();
	// Then recieve user inputs with basic sounds enabled
	for(int k = 0; k < replay_light; k++){  
		player_turn(true);
	}
	user_light = 0;
	// Then check if the user inputs were correct
	if(check_backwards()){
		if(replay_light == 0){
			winner();
		}
		else{
			// Remove last light in sequence
			replay_sequence[replay_light] = '\0';
			replay_light--;
		}
	}
		// Wrong sequence, game over
	else{
		game_over();
	}
}

void silly(){
	// Just some random garbage 👍
	// Feel free to delete
	for(int silly = 0; silly < 11; silly++){
		int rando = random(6);
		int randooo = random(20);
		digitalWrite(rando*2, HIGH);
		tone(buzzer, randooo*100);
		delay(250);
		noTone(buzzer);
		digitalWrite(randooo*2, LOW);
	}
	reset();
	setup();
}

void hmm(){
	// Har Har Har
	tone(buzzer, 784); // G5 Q
	digitalWrite(W_led, HIGH);
	delay(600);
	tone(buzzer, 880); // A5 .E
	digitalWrite(G_led, HIGH);
	delay(450);
	tone(buzzer, 784); // G5 S
	digitalWrite(Y_led, HIGH);
	delay(150);
	tone(buzzer, 659); // E5 Q
	digitalWrite(R_led, HIGH);
	delay(525);
	noTone(buzzer); // consecutive delay
	delay(75);
	tone(buzzer, 659); // E5 Q
	digitalWrite(B_led, HIGH);
	delay(525);
	noTone(buzzer); // consecutive delay
	delay(75);
	tone(buzzer, 659); // E5 .E
	digitalWrite(W_led, LOW);
	delay(450);
	tone(buzzer, 587); // D5 S
	digitalWrite(G_led, LOW);
	delay(150);
	tone(buzzer, 659); // E5 .E
	digitalWrite(Y_led, LOW);
	delay(450);
	tone(buzzer, 698); // F5 S
	digitalWrite(R_led, LOW);
	delay(150);
	tone(buzzer, 659); // E5 H
	digitalWrite(B_led, LOW);
	delay(1200);
	tone(buzzer, 698); // F5 Q
	digitalWrite(G_led, HIGH);
	delay(600);
	tone(buzzer, 587); // D5 .E
	digitalWrite(B_led, HIGH);
	delay(450);
	tone(buzzer, 784); // G5 s
	digitalWrite(R_led, HIGH);
	delay(150);
	tone(buzzer, 659); // E5 H
	digitalWrite(Y_led, HIGH);
	delay(1200);
	tone(buzzer, 523); // C5 Q
	digitalWrite(W_led, HIGH);
	delay(600);
	tone(buzzer, 440); // A4 .E
	digitalWrite(Y_led, LOW);
	digitalWrite(G_led, LOW);
	digitalWrite(R_led, LOW);
	digitalWrite(B_led, LOW);
	digitalWrite(W_led, LOW);
	delay(450);
	tone(buzzer, 587); // D5 S
	digitalWrite(Y_led, HIGH);
	digitalWrite(G_led, HIGH);
	digitalWrite(R_led, HIGH);
	digitalWrite(B_led, HIGH);
	digitalWrite(W_led, HIGH);
	delay(150);
	tone(buzzer, 415); // G#4 H
	digitalWrite(W_led, LOW);
	delay(600);
	digitalWrite(G_led, LOW);
	delay(300);
	digitalWrite(Y_led, LOW);
	delay(150);
	digitalWrite(R_led, LOW);
	delay(75);
	digitalWrite(B_led, LOW);
	noTone(buzzer);
	setup();
}

void reset(){
	// Reset all leds and the buzzer
	digitalWrite(Y_led, LOW);
	digitalWrite(B_led, LOW);
	digitalWrite(R_led, LOW);
	digitalWrite(G_led, LOW);
	digitalWrite(W_led, LOW);
	noTone(buzzer);
	delay(250);
}

void setup() {
	// Randomize seed (A0 should be floating and therefore random)
	randomSeed(analogRead(A0));
	// Setting pin modes
	pinMode(Y_led, OUTPUT);
	pinMode(B_led, OUTPUT);
	pinMode(R_led, OUTPUT);
	pinMode(G_led, OUTPUT);
	pinMode(W_led, OUTPUT);
	pinMode(buzzer, OUTPUT);
	pinMode(Y_button, INPUT_PULLUP);
	pinMode(B_button, INPUT_PULLUP);
	pinMode(R_button, INPUT_PULLUP);
	pinMode(G_button, INPUT_PULLUP);
	pinMode(W_button, INPUT_PULLUP);
	pinMode(Start_button, INPUT_PULLUP);
	//hmm();
	// Empty arrays with null character
	for(int n = 0; n <= sequence_length; n++){
		replay_sequence[n] = '\0';
		user_sequence[n] = '\0';
	}
	// Reset light counters
	replay_light = 0;
	user_light = 0;

	// Reset gamemode to default
	gamemode = 99;
	
	// Wait for user to choose a game mode
	while(true){
		if(digitalRead(Y_button) == LOW){
			// Classic
			gamemode = 0;
			while(digitalRead(Y_button) == LOW){
				// Easter egg check, if Y is held and then R is pressed, the easter egg is enabled
				if(digitalRead(R_button) == LOW){
				  easter_egg_check = true;
				}
			}
			reset();
			digitalWrite(Y_led, HIGH);
			// C4
			tone(buzzer, 262);
			delay(250);
			noTone(buzzer);
		}
		else if(digitalRead(B_button) == LOW){
			// Musical
			gamemode = 1;
			while(digitalRead(B_button) == LOW){}
			reset();
			digitalWrite(B_led, HIGH);
			// E4
			tone(buzzer, 330);
			delay(250);
			noTone(buzzer);
		}
		else if(digitalRead(R_button) == LOW){
			// Backwards
			gamemode = 2;
			while(digitalRead(R_button) == LOW){}
			reset();
			digitalWrite(R_led, HIGH);
			// G4
			tone(buzzer, 392);
			delay(250);
			noTone(buzzer);
		}
		else if(digitalRead(G_button) == LOW){
			// Silly
			gamemode = 3;
			while(digitalRead(G_button) == LOW){}
			reset();
			digitalWrite(G_led, HIGH);
			// B4
			tone(buzzer, 494);
			delay(250);
			noTone(buzzer);
		}
		else if(digitalRead(W_button) == LOW){
			// hmm
			gamemode = 4;
			while(digitalRead(W_button) == LOW){}
			reset();
			digitalWrite(W_led, HIGH);
			// C5
			tone(buzzer, 523);
			delay(250);
			noTone(buzzer);
		}
		else if(digitalRead(Start_button) == LOW){
			delay(100);
			// Wait for user to let go of button (so it doesn't activate multiple times)
			while(digitalRead(Start_button) == LOW){}
			switch(gamemode){
				case 0:
					// classic
					// Generate first of sequence
					generate_sequence();
					break;
				case 1:
					// musical
					// Choose random melody
					melody = random(3);
					start = 0;
					break;
				case 2:
					// backwards
					// Generate entire sequence
					for(int i = 0; i < round(difficulty-5); i++){
						generate_sequence();
					}
					break;
				case 99:
					// No selection yet, do nothing
					continue;
				default:
					break;
			}
			// After selection is confirmed, play start sequence/melody
			start_song();
			// Reset led and buzzer states
			reset();
			break;
		}
	}
}
void start_song() {
	// This is the start song
	digitalWrite(Y_led, HIGH);
	digitalWrite(B_led, HIGH);
	digitalWrite(R_led, HIGH);
	digitalWrite(G_led, HIGH);
	digitalWrite(W_led, HIGH);
	// C4
	tone(buzzer, 262);
	delay(200);
	// A4
	tone(buzzer, 440);
	delay(400);
	// G4
	tone(buzzer, 392);
	delay(100);
	// E4
	tone(buzzer, 330);
	delay(100);
	// B4
	tone(buzzer, 494);
	delay(200);
	// C5
	tone(buzzer, 524);
	delay(150);
}

void easter_egg() {
  // 🥚
}

void loop() {
	delay(250);
	// Main game loop, calls all other functions and loops
  // Easter egg!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
  if(easter_egg_check){
    easter_egg();
  }
	// Gamemode switch
	switch(gamemode){
		case 0:
			classic();
			break;
		case 1:
			musical();
			break;
		case 2:
			backwards();
			break;
		case 3:
			silly();
			break;
		case 4:
			hmm();
			break;
		default:
			break;
	}
}
